//结构体只能比较是否相等，但是不能比较大小。
//相同类型的结构体才能够进行比较，结构体是否相同不但与属性类型有关，还与属性顺序相关，sn3 与 sn1 就是不同的结构体；
//删除 map 不存在的键值对时，不会报错
//hello() 函数的参数在执行 defer 语句的时候会保存一份副本
//常量，Go 语言中的字符串是只读的。
//接口只能调用自己的方法
//第18天的题理解！
//golang 的字符串类型是不能赋值 nil 的，也不能跟 nil 比较
//map 的输出是无序的。

//new(T) 和 make(T,args) 是 Go 语言内建函数，用来分配内存，但适用的类型不同。
//new(T) 会为 T 类型的新值分配已置零的内存空间，并返回地址（指针），即类型为 *T的值。换句话说就是，返回一个指针，该指针指向新分配的、类型为 T 的零值。适用于值类型，如数组、结构体等。
//make(T,args) 返回初始化之后的 T 类型的值，这个值并不是 T 类型的零值，也不是指针 *T，是经过初始化之后的 T 的引用。make() 只适用于 slice、map 和 channel.
//值类型来说，你的每一次拷贝，Go 都会新申请一块内存空间，来存储它的值
// aArr := [3]int{0,1,2}//数组
//aslice := []int{0,1,2}//切片
//浅拷贝只是增加了一个指针指向已存在的内存地址，仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。深拷贝是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存。”
//值类型 ：String，Array，Int，Struct，Float，Bool
//引用类型：Slice，Map
//如果类型定义了 String() 方法，当使用 fmt.Printf()、fmt.Print() 和 fmt.Println() 会自动使用 String() 方法
//多重赋值分为两个步骤，有先后顺序：

//计算等号左边的索引表达式和取址表达式，接着计算等号右边的表达式；
   赋值；

//协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。
 //35题第三题

 //常量无法寻址。
 //nil可用做一个数据结构的空值
 //cap() 函数适用于数组、数组指针、slice 和 channel，不适用于 map，可以使用 len() 返回 map 的元素个数。
 //不能在单独的声明中重复声明一个变量，但在多变量声明的时候是可以的，但必须保证至少有一个变量是新声明的。
 //常量未使用是能编译通过的。
 //常量组中如不指定类型和初始化值，则与上一行非空常量右值相同
 //:= 操作符不能用于结构体字段赋值
 //函数只能与 nil 比较。
 //截取符号 [i:j]，如果 j 省略，默认是原切片或者数组的长度
